#!/usr/bin/env python

services = []
def service(name, iface, contractid):
    """Define a convenient service getter"""
    services.append((name, iface, contractid))

service('ChromeRegistryService', 'nsIChromeRegistry',
        "@mozilla.org/chrome/chrome-registry;1")
service('ToolkitChromeRegistryService', 'nsIToolkitChromeRegistry',
        "@mozilla.org/chrome/chrome-registry;1")
service('XULChromeRegistryService', 'nsIXULChromeRegistry',
        "@mozilla.org/chrome/chrome-registry;1")
service('XULOverlayProviderService', 'nsIXULOverlayProvider',
        "@mozilla.org/chrome/chrome-registry;1")
service('IOService', 'nsIIOService',
        "@mozilla.org/network/io-service;1")
service('ObserverService', 'nsIObserverService',
        "@mozilla.org/observer-service;1")
service('StringBundleService', 'nsIStringBundleService',
        "@mozilla.org/intl/stringbundle;1")
service('XPConnect', 'nsIXPConnect',
        "@mozilla.org/js/xpc/XPConnect;1")
service('InDOMUtils', 'inIDOMUtils',
        "@mozilla.org/inspector/dom-utils;1")
service('PermissionManager', 'nsIPermissionManager',
        "@mozilla.org/permissionmanager;1")
service('ServiceWorkerManager', 'nsIServiceWorkerManager',
        "@mozilla.org/serviceworkers/manager;1")
service('AsyncShutdown', 'nsIAsyncShutdownService',
        "@mozilla.org/async-shutdown-service;1")
service('UUIDGenerator', 'nsIUUIDGenerator',
        "@mozilla.org/uuid-generator;1")
service('GfxInfo', 'nsIGfxInfo',
        "@mozilla.org/gfx/info;1")
service('SocketTransportService', 'nsISocketTransportService',
        "@mozilla.org/network/socket-transport-service;1")
service('StreamTransportService', 'nsIStreamTransportService',
        "@mozilla.org/network/stream-transport-service;1")
service('CacheStorageService', 'nsICacheStorageService',
        "@mozilla.org/netwerk/cache-storage-service;1")
service('URIClassifier', 'nsIURIClassifier',
        "@mozilla.org/uriclassifierservice")
service('ActivityDistributor', 'nsIHttpActivityDistributor',
        "@mozilla.org/network/http-activity-distributor;1")
service('HistoryService', 'mozilla::IHistory',
        "@mozilla.org/browser/history;1")

# The definition file needs access to the definitions of the particular
# interfaces. If you add a new interface here, make sure the necessary includes
# are also listed in the following code snippet.
CPP_INCLUDES = """
#include "mozilla/Likely.h"
#include "mozilla/Services.h"
#include "nsComponentManager.h"
#include "nsIObserverService.h"
#include "nsNetCID.h"
#include "nsObserverService.h"
#include "nsXPCOMPrivate.h"
#include "nsIIOService.h"
#include "nsIDirectoryService.h"
#include "nsIChromeRegistry.h"
#include "nsIStringBundle.h"
#include "nsIToolkitChromeRegistry.h"
#include "nsIXULOverlayProvider.h"
#include "IHistory.h"
#include "nsIXPConnect.h"
#include "inIDOMUtils.h"
#include "nsIPermissionManager.h"
#include "nsIServiceWorkerManager.h"
#include "nsICacheStorageService.h"
#include "nsIStreamTransportService.h"
#include "nsISocketTransportService.h"
#include "nsIURIClassifier.h"
#include "nsIHttpActivityObserver.h"
#include "nsIAsyncShutdown.h"
#include "nsIUUIDGenerator.h"
#include "nsIGfxInfo.h"
"""

#####
# Codegen Logic
#
# The following code consumes the data listed above to generate the files
# Services.h, Services.cpp, and services.rs which provide access to these
# service getters in both rust and C++ code.
#
# XXX(nika): would it be a good idea to unify Services.jsm into here too?

def services_h(output):
    output.write("""\
/* THIS FILE IS GENERATED BY Services.py - DO NOT EDIT */

#ifndef mozilla_Services_h
#define mozilla_Services_h

#include "nscore.h"
#include "nsCOMPtr.h"
""")

    for (name, iface, contractid) in services:
        # Write out a forward declaration for the type in question
        segs = iface.split("::")
        for namespace in segs[:-1]:
            output.write("namespace {} {{\n".format(namespace))
        output.write("class {};\n".format(segs[-1]))
        for namespace in reversed(segs[:-1]):
            output.write("}} // namespace {}\n".format(namespace))

        # Write out the C-style function signature, and the C++ wrapper
        output.write("""
#ifdef MOZILLA_INTERNAL_API
extern "C" {{
/**
 * NOTE: Don't call this method directly, instead call mozilla::services::Get{0}.
 * It is used to expose XPCOM services to rust code. The return value is already addrefed.
 */
{1}* XPCOMService_Get{0}();
}} // extern "C"

namespace mozilla {{
namespace services {{
/**
 * Fetch a cached instance of the {0}.
 * This function will return nullptr during XPCOM shutdown.
 */
inline already_AddRefed<{1}>
Get{0}()
{{
  return already_AddRefed<{1}>(XPCOMService_Get{0}());
}}
}} // namespace services
}} // namespace mozilla
#endif // defined(MOZILLA_INTERNAL_API)
""".format(name, iface))

    output.write("#endif // !defined(mozilla_Services_h)\n")


def services_cpp(output):
    output.write("""\
/* THIS FILE IS GENERATED BY Services.py - DO NOT EDIT */
""")
    output.write(CPP_INCLUDES)

    for svc in services:
        output.write("""
static {1}* g{0} = nullptr;

extern "C" {{
/**
 * NOTE: Don't call this method directly, instead call `mozilla::services::Get{0}`.
 * This method is extern "C" to expose XPCOM services to rust code.
 * The return value is already addrefed.
 */
{1}*
XPCOMService_Get{0}()
{{
  if (MOZ_UNLIKELY(gXPCOMShuttingDown)) {{
    return nullptr;
  }}
  if (!g{0}) {{
    nsCOMPtr<{1}> os = do_GetService("{2}");
    os.swap(g{0});
  }}
  return do_AddRef(g{0}).take();
}}
}} // extern "C"
""".format(*svc))

    output.write("""
/**
 * Clears service cache, sets gXPCOMShuttingDown
 */
void
mozilla::services::Shutdown()
{
  gXPCOMShuttingDown = true;
""")
    for (name, iface, contractid) in services:
        output.write("  NS_IF_RELEASE(g{});\n".format(name))
    output.write("}\n")


def services_rs(output):
    output.write("""\
/* THIS FILE IS GENERATED BY Services.py - DO NOT EDIT */

use RefPtr;
""")

    for (name, iface, _) in services:
        # NOTE: We can't support namespaced interfaces in rust code, so we have to ignore them.
        if "::" in iface:
            continue

        output.write("""
/// Fetches a cached reference to the `{0}`.
/// This function will return `None` during XPCOM shutdown.
pub fn get_{0}() -> Option<RefPtr<::interfaces::{1}>> {{
    extern "C" {{
        fn XPCOMService_Get{0}() -> *mut ::interfaces::{1};
    }}
    unsafe {{ RefPtr::from_raw_dont_addref(XPCOMService_Get{0}()) }}
}}
""".format(name, iface))
