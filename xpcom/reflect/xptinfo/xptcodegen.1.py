#!/usr/bin/env python
# jsonlink.py - Merge JSON typelib files into a .cpp file
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# NOTE: Once shims are removed, this code can be cleaned up, removing all
# reference to them.

import json
import phf
import time
from collections import namedtuple, defaultdict

# We fix the number of entries in our intermediate table used by the perfect
# hashes to 256. This number is constant in xptinfo, allowing the compiler to
# generate a more efficient modulo due to it being a power of 2.
PHFSIZE = 256

# Helper methods for writing newlines with correct indentation.
_indent = "\n"
def indent():
    global _indent
    _indent += "  "
def dedent():
    global _indent
    _indent = _indent[:-2]
def nl(fd): # Write a newline to fd with the correct indentation
    fd.write(_indent)

# Write out a value based on its type. This code is pretty hot, so I try to
# keep type checks streamlined.
def dyn_write(fd, v):
    t = type(v)
    if t == str or t == unicode:
        fd.write(v)
    elif t == int:
        fd.write(str(v))
    elif t == bool:
        fd.write("true" if t else "false")
    else:
        v._write(fd)

# This type is used to wrap a value and details about what it represents.
# The detail is used for comments generated by struct(...).
ValDetail = namedtuple('ValDetail', ['value', 'detail'])
ValDetail._write = lambda self, fd: dyn_write(fd, self.value)

# Helper method used by struct(...)'s _write method.
def writestruct(self, fd):
    fd.write("{")
    indent()
    for f, v in zip(self._fields, self):
        nl(fd)
        dyn_write(fd, v)
        fd.write(", // " + f)
        if type(v) == ValDetail:
            fd.write(" = " + v.detail)
    dedent()
    nl(fd)
    fd.write("}")

# Helper function. Given a list of fields, generates a function which takes
# keyword arguments to construct an object of that type.
def struct(name, fields):
    ty = namedtuple(name, fields)
    ty._write = writestruct
    return ty

#######################################################
# IMPORTANT: The order of fields must match xptinfo.h #
#######################################################
interfaceinfo = struct(
    "nsXPTInterfaceInfo",
    [
        "mIID",
        "mName",
        "mParent",
        "mBuiltinClass",
        "mMainProcessScriptableOnly",
        "mMethods",
        "mConsts",
        "mIsShim",
        "mFunction",
        "mNumMethods",
        "mNumConsts",
    ]
)

#######################################################
# IMPORTANT: The order of fields must match xptinfo.h #
#######################################################
typeinfo = struct(
    "nsXPTType",
    [
        "mTag",
        "mInParam",
        "mOutParam",
        "mOptionalParam",
        "mData1",
        "mData2",
    ]
)

#######################################################
# IMPORTANT: The order of fields must match xptinfo.h #
#######################################################
paraminfo = struct(
    "nsXPTParamInfo",
    [
        "mType",
    ]
)

#######################################################
# IMPORTANT: The order of fields must match xptinfo.h #
#######################################################
methodinfo = struct(
    "nsXPTMethodInfo",
    [
        "mName",
        "mParams",
        "mNumParams",
        "mGetter",
        "mSetter",
        "mNotXPCOM",
        "mHidden",
        "mOptArgc",
        "mContext",
        "mHasRetval",
    ]
)

#######################################################
# IMPORTANT: The order of fields must match xptinfo.h #
#######################################################
domobjectinfo = struct(
    "nsXPTDOMObjectInfo",
    [
        "mUnwrap",
        "mWrap",
        "mCleanup",
    ]
)

#######################################################
# IMPORTANT: The order of fields must match xptinfo.h #
#######################################################
constinfo = struct(
    "nsXPTConstInfo",
    [
        "mName",
        "mSigned",
        "mValue",
    ]
)

# Helper functions for dealing with IIDs
def split_at_idxs(s, lengths):
    idx = 0
    for length in lengths:
        yield s[idx:idx + length]
        idx += length
    assert idx == len(s)

def split_iid(iid): # Get the individual components out of an IID string.
    iid = iid.replace('-', '') # Strip any '-' delimiters
    return tuple(split_at_idxs(iid, (8, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2)))

def iid_bytes(iid): # Get the byte representation of the IID for hashing.
    bs = bytearray()
    # We store the bytes in little-endian (XXX: Big endian support?)
    for num in split_iid(iid):
        b = bytearray.fromhex(num)
        b.reverse()
        bs += b
    return bs

# Helper for interacting with the flags field of a jsonxpt object
class Flags(object):
    def __init__(self, d):
        self.flags = d['flags']

    def __getattr__(self, name):
        if name[-1] == '_': # Strip optional trailing _ for keywords (in)
            name = name[:-1]
        return name in self.flags


# Data table of C++ objects. Optionally cached by a key.
class CTable(object):
    def __init__(self, ty, name):
        self.ty = ty
        self.name = name
        self.items = []
        self.comments = defaultdict(set)
        self.cache = {}

    def one(self, comment, entry, key=None):
        return self.add(comment, lambda: (entry,), key=key)

    # Add N entries to the table. Takes an itemgen function to avoid
    # unnecessary work when a match is avaliable.
    def add(self, comment, itemgen, key=None):
        if key is not None: # Check if we're in cache
            idx = self.cache.get(key)
            if idx is not None:
                self.comments[idx].add(comment)
                return ValDetail(idx, comment)

        idx = len(self.items)
        self.items.extend(itemgen())
        if len(self.items) == idx:
            return ValDetail(0, comment) # added nothing

        if key is not None:
            self.cache[key] = idx

        self.comments[idx].add(comment)
        return ValDetail(idx, comment)

    # If we have comments, break the line & write it out.
    def write_comments(self, fd, idx):
        comments = self.comments.get(idx)
        if comments is not None:
            nl(fd)
            for comment in sorted(comments):
                fd.write('// %s[%d] = %s' % (self.name, idx, comment))
                nl(fd)

    # Write out the C++ table
    def _write(self, fd):
        fd.write("const %s nsXPTData::%s = {" % (self.ty, self.name))
        indent()
        for idx, it in enumerate(self.items):
            self.write_comments(fd, idx)
            dyn_write(fd, it)
            fd.write(',')
        dedent()
        fd.write("\n};\n\n")

def link_to_cpp(interfaces, fd):
    iid_phf = phf.PHF(PHFSIZE, [ # Perfect Hash from IID into the ifaces array.
        (iid_bytes(iface['uuid']), iface)
        for iface in interfaces
    ])
    name_phf = phf.PHF(PHFSIZE, [ # Perfect Hash from name to index in the ifaces array.
        (bytearray(iface['name'], 'ascii'), idx)
        for idx, iface in enumerate(iid_phf.values)
    ])

    def interface_idx(name):
        if name is not None:
            idx = name_phf.lookup(bytearray(name, 'ascii'))
            if iid_phf.values[idx]['name'] == name:
                return ValDetail(idx + 1, name) # One-based, so we can use 0 as a sentinel.
        return ValDetail(0, "<unresolved>")

    # NOTE: State used while linking. This is done with closures rather than a
    # class due to how this file's code evolved.
    includes = set()
    ifaces = CTable("nsXPTInterfaceInfo", "sInterfaces")
    types = CTable("nsXPTType", "sTypes")
    params = CTable("nsXPTParamInfo", "sParams")
    methods = CTable("nsXPTMethodInfo", "sMethods")
    consts = CTable("ConstInfo", "sConsts")
    prophooks = CTable("mozilla::dom::NativePropertyHooks*", "sPropHooks")
    domobjects = CTable("nsXPTDOMObjectInfo", "sDOMObjects")
    strings = CTable("char", "sStrings")

    def lower_uuid(uuid):
        return "{0x%s, 0x%s, 0x%s, {0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s}}" % split_iid(uuid)

    def lower_string(s):
        return strings.add(s, lambda: ["'%s'" % c for c in s] + ["'\\0'"], key=s)

    def lower_domobject(do):
        assert do['tag'] == 'TD_DOMOBJECT'

        includes.add(do['headerFile'])
        return domobjectinfo(
            # These methods are defined at the top of the generated file.
            mUnwrap="UnwrapDOMObject<dom::prototypes::id::%s, %s>" %
                (do['name'], do['native']),
            mWrap="WrapDOMObject<%s>" % do['native'],
            mCleanup="CleanupDOMObject<%s>" % do['native'],
        )

    def describe_type(ty): # Create the type's documentation comment.
        tag = ty['tag'][3:].lower()
        if tag == 'array':
            return '%s[size_is=%d]' % (
                describe_type(ty['element']), ty['size_is'])
        elif tag == 'interface_type' or tag == 'domobject':
            return ty['name']
        elif tag == 'interface_is_type':
            return 'iid_is(%d)' % ty['iid_is']
        elif tag.endswith('_size_is'):
            return '%s(size_is=%d)' % (tag, ty['size_is'])
        return tag

    def lower_type(ty, in_=0, out=0, optional=0):
        tag = ty['tag']
        d1 = d2 = 0

        if tag == 'TD_ARRAY':
            d1 = ty['size_is']

            desc = describe_type(ty['element'])
            d2 = types.add(desc, lambda: [lower_type(ty['element'])],
                           key=desc).value

        elif tag == 'TD_INTERFACE_TYPE':
            idx = interface_idx(ty['name'])
            d1 = idx.value >> 8
            d2 = idx.value & 0xff

        elif tag == 'TD_INTERFACE_IS_TYPE':
            d1 = ty['iid_is']

        elif tag == 'TD_DOMOBJECT':
            idx = domobjects.add(ty['name'],
                                 lambda: [lower_domobject(ty)],
                                 key=ty['name'])
            d1 = idx.value >> 8
            d2 = idx.value & 0xff

        elif tag.endswith('_SIZE_IS'):
            d1 = ty['size_is']

        assert d1 < 256 and d2 < 256, "Data values too large"
        return typeinfo(
            mTag=tag,
            mData1=d1,
            mData2=d2,

            # These fields are used by parameters.
            mInParam=in_,
            mOutParam=out,
            mOptionalParam=optional,
        )

    def describe_param(param):
        flags = Flags(param)
        s = describe_type(param['type'])
        if flags.in_: s = "in " + s
        if flags.out: s = "out " + s
        if flags.optional: s = "optional " + s
        return s

    def lower_param(param):
        flags = Flags(param)
        return paraminfo(
            mType=ValDetail(
                lower_type(param['type'],
                           in_=flags.in_,
                           out=flags.out,
                           optional=flags.optional),
                describe_param(param),
            )
        )

    def lower_method(method, ifacename):
        flags = Flags(method)

        hideparams = flags.notxpcom or flags.hidden

        paramoff = numparams = nameoff = 0
        if not hideparams: # save space - don't generate hidden params
            nameoff = lower_string(method['name'])
            numparams = len(method['params'])
            paramoff = params.add(
                "%dx %s::%s(*)" % (numparams, ifacename, method['name']),
                lambda: [lower_param(param) for param in method['params']],
                key=tuple(describe_param(param) for param in method['params']))

        return methodinfo(
            mName=nameoff,
            mParams=paramoff,
            mNumParams=numparams,

            # Flags
            mGetter=flags.getter,
            mSetter=flags.setter,
            mNotXPCOM=flags.notxpcom,
            mHidden=flags.hidden,
            mOptArgc=flags.optargc,
            mContext=flags.jscontext,
            mHasRetval=flags.hasretval,
        )

    def lower_const(const):
        assert const['type']['tag'] in \
            ['TD_INT16', 'TD_INT32', 'TD_UINT16', 'TD_UINT32']
        is_signed = const['type']['tag'] in ['TD_INT16', 'TD_INT32']

        # Constants are always either signed or unsigned 16 or 32 bit integers,
        # which we will only need to convert to JS values. To save on space,
        # don't bother storing the type, and instead just store a 32-bit
        # unsigned integer, and stash whether to interpret it as signed.
        return constinfo(
            mName=lower_string(const['name']),
            mSigned=is_signed,
            mValue="(uint32_t) %d" % const['value'],
        )

    def lower_prop_hooks(iface): # XXX: Used by xpt shims
        assert iface['shim'] is not None

        includes.add("mozilla/dom/%sBinding.h" %
            (iface['shimfile'] or iface['shim']))
        return "mozilla::dom::%sBinding::sNativePropertyHooks" % iface['shim']

    def collect_base_info(iface):
        methods = 0
        consts = 0
        builtinclass = False
        while iface is not None:
            methods += len(iface['methods'])
            consts += len(iface['consts'])
            # We're builtinclass if any of our bases are.
            builtinclass = builtinclass or Flags(iface).builtinclass
            idx = interface_idx(iface['parent']).value
            if idx == 0:
                break
            iface = iid_phf.values[idx - 1]

        return methods, consts, builtinclass

    def lower_iface(iface):
        flags = Flags(iface)

        isshim = iface['shim'] is not None
        assert isshim or flags.scriptable

        methods_off = method_cnt = const_cnt = 0
        if isshim:
            # If we are looking at a shim, don't lower any methods or constants,
            # as they will be pulled from the WebIDL binding instead. Instead,
            # we use the constants offset field to store the index into the prop
            # hooks table.
            consts_off = prophooks.add("%s::*" % iface['name'],
                                       lambda: [lower_prop_hooks(iface)],
                                       key=iface['shim'])
            builtinclass = True  # All shims are builtinclass
        else:
            method_cnt, const_cnt, builtinclass = collect_base_info(iface)

            # Lower methods & constants
            methods_off = methods.add(
                "%dx %s::*" % (len(iface['methods']), iface['name']),
                lambda: [lower_method(method, iface['name'])
                         for method in iface['methods']])

            consts_off = consts.add(
                "%dx %s::*" % (len(iface['consts']), iface['name']),
                lambda: [lower_const(const) for const in iface['consts']])

        # Create the interface object
        return interfaceinfo(
            mIID=lower_uuid(iface['uuid']),
            mName=lower_string(iface['name']),
            mParent=interface_idx(iface['parent']),

            mMethods=methods_off,
            mNumMethods=method_cnt,
            mConsts=consts_off,
            mNumConsts=const_cnt,

            # Flags
            mIsShim=isshim,
            mBuiltinClass=builtinclass,
            mMainProcessScriptableOnly=flags.main_process_only,
            mFunction=flags.function,
        )

    # Lower interfaces in the order of the IID phf's values lookup.
    for idx, iface in enumerate(iid_phf.values):
        i = ifaces.one(iface['name'], lower_iface(iface))
        assert i.value == idx, "Wrong index for interface!"

    # Write out the final output file
    fd.write("/* THIS FILE WAS GENERATED BY xptcodegen.py - DO NOT EDIT */\n\n")

    # Include additional headers required by generated code
    for include in sorted(includes):
        fd.write('#include "%s"\n' % include)

    # Write our out header
    fd.write("""
#include "xptinfo.h"
#include "mozilla/TypeTraits.h"
#include "mozilla/dom/BindingUtils.h"

// These template methods are specialized to be used in the sDOMObjects table.
template<dom::prototypes::ID PrototypeID, typename T>
static nsresult UnwrapDOMObject(JS::HandleValue aHandle, void** aObj)
{
  RefPtr<T> p;
  nsresult rv = dom::UnwrapObject<PrototypeID, T>(aHandle, p);
  p.forget(aObj);
  return rv;
}

template<typename T>
static bool WrapDOMObject(JSContext* aCx, void* aObj, JS::MutableHandleValue aHandle)
{
  return dom::GetOrCreateDOMReflector(aCx, reinterpret_cast<T*>(aObj), aHandle);
}

template<typename T>
static void CleanupDOMObject(void* aObj)
{
  RefPtr<T> p = already_AddRefed<T>(reinterpret_cast<T*>(aObj));
}

""")

    # Static data arrays
    ifaces._write(fd)
    types._write(fd)
    params._write(fd)
    methods._write(fd)
    domobjects._write(fd)
    consts._write(fd)
    prophooks._write(fd)
    strings._write(fd)

    # Record the information required for perfect hashing.
    def phfarr(name, ty, it):
        fd.write("const %s nsXPTData::%s[] = {" % (ty, name))
        for idx, v in enumerate(it):
            if idx % 8 == 0:
                fd.write('\n ')
            fd.write(" 0x%08x," % v)
        fd.write("\n};\n\n")
    phfarr("sPHF_IIDs", "uint32_t", iid_phf.inter)
    phfarr("sPHF_Names", "uint32_t", name_phf.inter)
    phfarr("sPHF_NamesIdxs", "uint16_t", name_phf.values)

    # The footer contains some checks re: the size of the generated arrays.
    fd.write("""\
const uint16_t nsXPTData::sInterfacesSize = mozilla::ArrayLength(nsXPTData::sInterfaces);
static_assert(nsXPTData::sInterfacesSize == mozilla::ArrayLength(nsXPTData::sPHF_NamesIdxs),
              "sPHF_NamesIdxs must have same size as sInterfaces");

static_assert(nsXPTData::kPHFSize == mozilla::ArrayLength(nsXPTData::sPHF_Names),
              "sPHF_IIDs must have size kPHFSize");
static_assert(nsXPTData::kPHFSize == mozilla::ArrayLength(nsXPTData::sPHF_IIDs),
              "sPHF_Names must have size kPHFSize");

""")

def link_and_write(files, outfile):
    interfaces = []
    for file in files:
        with open(file, 'r') as fd:
            interfaces += json.load(fd)

    link_to_cpp(interfaces, outfile)

def main():
    from argparse import ArgumentParser
    import sys

    parser = ArgumentParser()
    parser.add_argument('outfile', help='Output C++ file to generate')
    parser.add_argument('xpts', nargs='*', help='source xpt files')

    args = parser.parse_args(sys.argv[1:])
    with open(args.outfile, 'w') as fd:
        link_and_write(args.xpts, fd)

if __name__ == '__main__':
    import cProfile
    cProfile.run('main()')
